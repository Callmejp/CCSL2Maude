fmod CLOCK is
  including QID .
  including BOOL .
  sorts Clock ClockSet .
  subsort Qid < Clock < ClockSet .
  op empty : -> Clock .
  op _,_ : ClockSet ClockSet -> ClockSet [ctor assoc comm id: empty] .
  op _in_ : Clock ClockSet -> Bool .
  
  vars C1 C2 : Clock .
  var CS1 : ClockSet .
  eq C1 in empty = false .
  eq C1 in (C2, CS1) = 
    if (C1 == C2) then true else C1 in CS1 fi .
endfm 

fmod TICK-LIST is 
  including INT .
  sort TickList .
  subsort Int < TickList .
  op nil : -> TickList .
  op _,_ : Int TickList -> TickList [id: nil].

  vars N1 N2 : Int .
  var TL1 : TickList .

  op get : TickList Int -> Int .
  eq get((N2, TL1), N1) = 
    if N1 == 1 then N2 else get(TL1, N1 - 1) fi .

  op cal : TickList Int -> Int .
  eq cal(TL1, 0) = 0 .
  eq cal((1, TL1), N1) = cal(TL1, N1 - 1) + 1 .
  eq cal((0, TL1), N1) = cal(TL1, N1 - 1) .
endfm

fmod CONSTRAINTS is
  including CLOCK .
  including NAT .
  sorts Constraint Constraints .
  subsort Constraint < Constraints .
  op empty : -> Constraints [ctor] .
  op __ : Constraints Constraints -> Constraints [ctor assoc comm id: empty] .
  op _<_     : Clock Clock       -> Constraint [ctor] .
  op _!=_$_  : Clock Clock Nat   -> Constraint [ctor] .
  op _!=_+_  : Clock Clock Clock -> Constraint [ctor] .
  op _!=_*_  : Clock Clock Clock -> Constraint [ctor] .
  op _!=_/\_ : Clock Clock Clock -> Constraint [ctor] .
  op _!=_\/_ : Clock Clock Clock -> Constraint [ctor] .
  op _<<_    : Clock Clock       -> Constraint [ctor] .
  op _#_     : Clock Clock       -> Constraint [ctor] .
  op _<=_    : Clock Clock       -> Constraint [ctor] .
  op _!=_~_  : Clock Clock Nat -> Constraint [ctor] .
endfm 

fmod CONFIGURATION is 
  including NAT + CLOCK + TICK-LIST . 
  sort ConfElt Conf .
  subsort ConfElt < Conf .
  op [_,_,_] : Clock TickList Nat -> ConfElt [ctor] .
  op empty : -> Conf [ctor] .
  op _,_ : Conf Conf -> Conf [ctor assoc comm id: empty] .
endfm

mod MAIN is 
  including BOOL .
  including CLOCK .
  including NAT .
  including CONSTRAINTS .
  including CONFIGURATION .
  including TICK-LIST .
  sort CCSLState .

  op <_;_;_;_> : ClockSet Constraints Conf Nat -> CCSLState [ctor] .
  op satisfy : ClockSet Conf Constraint -> Bool .

  vars F F' : ClockSet .
  var CON : Constraint .
  var PHI : Constraints .
  var X : Conf .
  var Y : ConfElt .
  vars K N N1 N2 N3 K' : Nat .
  vars C1 C2 C3 : Clock .
  vars TL1 TL2 TL3 : TickList .
  
  --- General
  eq satisfy(F, X, empty) = true .
  
  --- Precedence
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], X), C1 < C2) =
    if N1 == N2 then not (C2 in F) else true fi .
  
  --- Delay
  eq satisfy(F, ([C2, TL2, N2], X), C1 != C2 $ N) = 
    if N2 >= N then (C1 in F) == (C2 in F) else not (C1 in F) fi . 
  
  --- Periodicity
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], X), C1 != C2 ~ N) =
    if (N2 + 1) rem N == 0 then (C1 in F == C2 in F) else not (C1 in F) fi .
  
  --- Intersection
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], [C3, TL3, N3], X), C1 != C2 * C3) = 
    if (C1 in F) then ((C2 in F) and (C3 in F)) else (not ((C2 in F) and (C3 in F))) fi .
  
  --- Union 
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], [C3, TL3, N3], X), C1 != C2 + C3) = 
    if (C1 in F) then ((C2 in F) or (C3 in F)) else (not ((C2 in F) or (C3 in F))) fi .

  --- Supremum
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], [C3, TL3, N3], X), C1 != C2 \/ C3) = 
    (if N2 < N3 then (C1 in F) == (C2 in F) else
        (if N2 > N3 then (C1 in F) == (C3 in F) else 
                (C1 in F) == (C2 in F and C3 in F)
        fi) 
    fi) .
  
  --- Infimum
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], [C3, TL3, N3], X), C1 != C2 /\ C3) = 
    (if N2 > N3 then (C1 in F) == (C2 in F) else
        (if N2 < N3 then (C1 in F) == (C3 in F) else 
            (C1 in F) == (C2 in F or C3 in F)
        fi) 
    fi) .
  
  --- Subclock
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], X), C1 << C2) = 
    if not (C1 in F) or (C2 in F) then true else false fi .
  
  --- Exclusion
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], X), C1 # C2) =
    if not (C1 in F) or not (C2 in F) then true else false fi .
  
  --- Causality
  eq satisfy(F, ([C1, TL1, N1], [C2, TL2, N2], X), C1 <= C2 ) =
    (if (N1 > N2) then true else 
     (if (N1 ==  N2) then ((C2 in F) and (not (C1 in F))) else true 
     fi)
    fi) . 
  
  eq satisfy(F, X, (CON PHI)) = if (satisfy(F, X, CON)) then satisfy(F, X, PHI) else false fi .
  
  --- update here
  op update : Conf ClockSet -> Conf .
  eq update(([C1, TL1, N1], X), F) = 
    if (C1 in F) then ([C1, (TL1, 1), N1 + 1], update(X, F)) else ([C1, (TL1, 0), N1], update(X, F)) fi .
  eq update(empty, F) = empty .

  crl < (F, F') ; PHI ; X ; K > => < (F, F') ; PHI ; update(X, F) ; K + 1 >
    if F =/= empty /\ satisfy(F, X, PHI) .

  --- Declaration and definition of getPeriod and isPeriodic
  op getPeriod  : Conf Constraints Nat Nat -> Nat .
  op isPeriodic : Conf Constraints Nat Nat -> Bool .
  eq getPeriod(X, PHI, K, K') =
    if K > 0 then (if isPeriodic(X, PHI, K, K') then sd(K', K) else getPeriod(X, PHI, sd(K, 1), K') fi)
	else 0 fi .

  eq isPeriodic(([C1, TL1, N1], [C2, TL2, N2], X), (C1 < C2) PHI, K, K') = 
    get(TL1, K) == get(TL1, K') and
	get(TL2, K) == get(TL2, K') and
	sd(N1, cal(TL1, K)) >= sd(N2, cal(TL2, K)) and
	isPeriodic(X, PHI, K, K') .

endm
